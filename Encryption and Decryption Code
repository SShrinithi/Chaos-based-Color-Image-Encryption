import cv2
import numpy as np
import matplotlib.pyplot as plt
import struct
import time
import os
from google.colab import files

# Step 1: Upload Image
uploaded = files.upload()
for filename in uploaded.keys():
    img = cv2.imread(filename)
    img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)

# Ensure if the image is square
h, w, _ = img.shape
N = min(h, w)
img = cv2.resize(img, (N, N))

# Split into R, G, B channels
R, G, B = cv2.split(img)

# Encryption Time Calculation
start_time = time.time()

# ENCRYPTION

# Step 2: 2D Standard Map Scrambling
def standard_map(N, K=0.5, iterations=100):
    theta, p = np.meshgrid(np.linspace(0, 2 * np.pi, N), np.linspace(0, 2 * np.pi, N))

    for _ in range(iterations):
        p = (p + K * np.sin(theta)) % (2 * np.pi)
        theta = (theta + p) % (2 * np.pi)

    sorted_indices = np.argsort(theta.ravel())
    return sorted_indices.reshape(N, N)

def standard_scramble(channel, N):
    indices = standard_map(N).flatten()
    scrambled = channel.flatten()[indices].reshape(N, N)
    return scrambled, indices.reshape(N, N)

R_scrambled, R_map = standard_scramble(R, N)
G_scrambled, G_map = standard_scramble(G, N)
B_scrambled, B_map = standard_scramble(B, N)


# Step 3: Generate First Encryption Key
def logistic_sine_map(n, x0=0.3, y0=0.3, a=0.9):
    x, y = x0, y0
    x_seq, y_seq = [], []
    for _ in range(n):
        x = np.sin(np.pi * a * (y + 3) * x * (1 - x))
        y = np.sin(np.pi * a * (x + 4) * y * (1 - y))
        x_seq.append(x)
        y_seq.append(y)
    return np.array(x_seq), np.array(y_seq)

def linear_congruential_generator(n, L1_0=3538644446, aL1=27, c1=0, m1=2**52-1,
                                  L2_0=2700000, aL2=37, c2=1, m2=2**32-1):
    L1, L2 = L1_0, L2_0
    sequence_L1, sequence_L2 = [], []

    for _ in range(n):
        L1 = (aL1 * L1 + c1) % m1
        L2 = (aL2 * L2 + c2) % m2
        sequence_L1.append(L1)
        sequence_L2.append(L2)

    return np.array(sequence_L1, dtype=np.uint64), np.array(sequence_L2, dtype=np.uint64)  # Use uint64 to prevent overflow


N_total = N * N

L1_seq, L2_seq = linear_congruential_generator(N_total)

L1_seq = (L1_seq % (2**52)).astype(np.uint64)
L2_seq = (L2_seq % (2**32)).astype(np.uint32)

x_seq, y_seq = logistic_sine_map(N_total)
x_seq_bits = np.array([struct.unpack('Q', struct.pack('d', x))[0] for x in x_seq], dtype=np.uint64)
y_seq_bits = np.array([struct.unpack('Q', struct.pack('d', y))[0] for y in y_seq], dtype=np.uint64)


a_bits = np.array(int(0.9 * (2**44)) & ((1 << 44) - 1), dtype=np.uint64)


# Step 4: Construct the 256Ã—256-bit Encryption Key
key_matrix = np.zeros(N_total, dtype=np.uint64)

for i in range(N_total):
    key_matrix[i] = ((x_seq_bits[i] & ((1 << 64) - 1)) << (64 + 44)) | \
                    ((y_seq_bits[i] & ((1 << 64) - 1)) << 44) | \
                    (a_bits << 32) | \
                    ((L1_seq[i] & ((1 << 52) - 1)) << 32) | \
                    (L2_seq[i] & ((1 << 32) - 1))

key_matrix = (key_matrix % 256).astype(np.uint8).reshape(N, N)

def xor_bitwise_submatrices(channel, key):
    channel_bits = np.unpackbits(channel.astype(np.uint8), axis=1)
    key_bits = np.unpackbits(key.astype(np.uint8), axis=1)

    xor_result = np.bitwise_xor(channel_bits, key_bits)

    return np.packbits(xor_result, axis=1).reshape(channel.shape).astype(np.uint8)

R_encrypted = xor_bitwise_submatrices(R_scrambled, key_matrix)
G_encrypted = xor_bitwise_submatrices(G_scrambled, key_matrix)
B_encrypted = xor_bitwise_submatrices(B_scrambled, key_matrix)

# Step 5: Generate Second Encryption Key
def lorenz_key_generator(n_bytes, x0=0.1, y0=0.1, z0=0.1, sigma=10, rho=28, beta=8/3, dt=0.01, warmup=1000):
    x, y, z = x0, y0, z0
    key_bytes = []

    # Warm-up
    for _ in range(warmup):
        dx = sigma * (y - x)
        dy = x * (rho - z) - y
        dz = x * y - beta * z
        x += dx * dt
        y += dy * dt
        z += dz * dt
    # Generate
    while len(key_bytes) < n_bytes:
        dx = sigma * (y - x)
        dy = x * (rho - z) - y
        dz = x * y - beta * z
        x += dx * dt
        y += dy * dt
        z += dz * dt

        val = abs((x + y + z) % 1)
        byte = int(val * 256) % 256
        key_bytes.append(byte)

    return np.array(key_bytes, dtype=np.uint8)

# Generate key2 matrix
key2_matrix = lorenz_key_generator(N * N).reshape(N, N)

# Step 6: XOR with Second Key
R_final_encrypted = xor_bitwise_submatrices(R_encrypted, key2_matrix)
G_final_encrypted = xor_bitwise_submatrices(G_encrypted, key2_matrix)
B_final_encrypted = xor_bitwise_submatrices(B_encrypted, key2_matrix)

# Encryption to image
final_encrypted_img = cv2.merge([R_final_encrypted, G_final_encrypted, B_final_encrypted])

end_time = time.time()

# Save the encrypted RGB channels for future use
cv2.imwrite("encrypted_R_channel.png", cv2.merge([R_final_encrypted.astype(np.uint8)] * 3))
cv2.imwrite("encrypted_G_channel.png", cv2.merge([G_final_encrypted.astype(np.uint8)] * 3))
cv2.imwrite("encrypted_B_channel.png", cv2.merge([B_final_encrypted.astype(np.uint8)] * 3))
print("Encrypted channel images saved successfully!")

# Function to convert a NumPy array into a string of 0s and 1s
def array_to_bitstream(array):
    return ''.join(format(val, '08b') for val in array.flatten())

# Convert all encrypted channels and keys to bitstreams
R_bits = array_to_bitstream(R_final_encrypted)
G_bits = array_to_bitstream(G_final_encrypted)
B_bits = array_to_bitstream(B_final_encrypted)
final_img_bits = array_to_bitstream(final_encrypted_img)
key1_bits = array_to_bitstream(key_matrix)
key2_bits = array_to_bitstream(key2_matrix)

# Save the bitstreams to text files
with open("/content/encrypted_R_channel_bits.txt", "w") as f: f.write(R_bits)
with open("/content/encrypted_G_channel_bits.txt", "w") as f: f.write(G_bits)
with open("/content/encrypted_B_channel_bits.txt", "w") as f: f.write(B_bits)
with open("/content/final_encrypted_image_bits.txt", "w") as f: f.write(final_img_bits)
with open("/content/key1_bits.txt", "w") as f: f.write(key1_bits)
with open("/content/key2_bits.txt", "w") as f: f.write(key2_bits)

print("Bitstream files saved successfully for NIST analysis!")


encryption_time = end_time - start_time
print(f"Encryption Time: {encryption_time:.6f} seconds")

# DECRYPTION
R_enc, G_enc, B_enc = R_final_encrypted, G_final_encrypted, B_final_encrypted
# Reverse XOR with second key
R_partial = xor_bitwise_submatrices(R_enc, key2_matrix)
G_partial = xor_bitwise_submatrices(G_enc, key2_matrix)
B_partial = xor_bitwise_submatrices(B_enc, key2_matrix)

# Reverse XOR with first key
R_decrypted = xor_bitwise_submatrices(R_partial, key_matrix)
G_decrypted = xor_bitwise_submatrices(G_partial, key_matrix)
B_decrypted = xor_bitwise_submatrices(B_partial, key_matrix)

# Reverse Scrambling
def inverse_scramble(channel, mapping):
    N = channel.shape[0]
    unscrambled = np.empty_like(channel)
    unscrambled.flat[mapping.ravel()] = channel.flat
    return unscrambled

R_final = inverse_scramble(R_decrypted, R_map)
G_final = inverse_scramble(G_decrypted, G_map)
B_final = inverse_scramble(B_decrypted, B_map)

final_decrypted_img = cv2.merge([R_final, G_final, B_final])

# CHECKING IF DECRYPTION SUCCEEDED OR NOT
if np.array_equal(img, final_decrypted_img):
    print("Decryption successful!")
else:
    print("Decryption failed.")

# DISPLAYING IMAGES
fig, axes = plt.subplots(4, 4, figsize=(20, 20))

axes[0, 0].imshow(img)
axes[0, 0].set_title("Original Image")
axes[0, 0].axis("off")

axes[0, 1].imshow(R, cmap="Reds")
axes[0, 1].set_title("Red Channel of Original Image")
axes[0, 1].axis("off")

axes[0, 2].imshow(G, cmap="Greens")
axes[0, 2].set_title("Green Channel of Original Image")
axes[0, 2].axis("off")

axes[0, 3].imshow(B, cmap="Blues")
axes[0, 3].set_title("Blue Channel of Original Image")
axes[0, 3].axis("off")

axes[1, 0].imshow(R_scrambled, cmap="Reds")
axes[1, 0].set_title("Scrambled Red Channel")
axes[1, 0].axis("off")

axes[1, 1].imshow(G_scrambled, cmap="Greens")
axes[1, 1].set_title("Scrambled Green Channel")
axes[1, 1].axis("off")

axes[1, 2].imshow(B_scrambled, cmap="Blues")
axes[1, 2].set_title("Scrambled Blue Channel")
axes[1, 2].axis("off")

axes[1, 3].imshow(final_encrypted_img)
axes[1, 3].set_title("Final Encrypted Image")
axes[1, 3].axis("off")

axes[2, 0].imshow(cv2.merge([R_partial, G_partial, B_partial]))
axes[2, 0].set_title("After Reverse XOR of Keys")
axes[2, 0].axis("off")

axes[2, 1].imshow(cv2.merge([R_final, G_final, B_final]))
axes[2, 1].set_title("After Reverse Scrambling")
axes[2, 1].axis("off")

axes[2, 2].imshow(R_decrypted, cmap="Reds")
axes[2, 2].set_title("Final R Decrypted Image")
axes[2, 2].axis("off")

axes[2, 3].imshow(B_decrypted, cmap="Blues")
axes[2, 3].set_title("Final B Decrypted Image")
axes[2, 3].axis("off")

axes[3, 0].imshow(G_decrypted, cmap="Greens")
axes[3, 0].set_title("Final G Decrypted Image")
axes[3, 0].axis("off")

axes[3, 1].imshow(final_decrypted_img)
axes[3, 1].set_title("Final Decrypted Image")
axes[3, 1].axis("off")

fig.delaxes(axes[3, 2])
fig.delaxes(axes[3, 3])

plt.tight_layout()
plt.show()

cv2.imwrite("original.png", cv2.cvtColor(img, cv2.COLOR_RGB2BGR))
cv2.imwrite("encrypted.png", cv2.cvtColor(final_encrypted_img, cv2.COLOR_RGB2BGR))
cv2.imwrite("decrypted.png", cv2.cvtColor(final_decrypted_img, cv2.COLOR_RGB2BGR))

print("Encryption & Decryption Complete.")
